<?php

declare(strict_types=1);

namespace Jasny\SwitchRoute\Generator;

use Jasny\SwitchRoute\Endpoint;
use Jasny\SwitchRoute\InvalidRoute;
use Jasny\SwitchRoute\Invoker;
use Jasny\SwitchRoute\InvokerInterface;
use Jasny\SwitchRoute\Routes;
use ReflectionException;

/**
 * Generate a function that invokes an action based on the route.
 */
class GenerateFunction extends AbstractGenerate
{
    /**
     * @var InvokerInterface
     */
    protected $invoker;

    /**
     * GenerateScript constructor.
     *
     * @param InvokerInterface $invoker
     */
    public function __construct(InvokerInterface $invoker = null)
    {
        $this->invoker = $invoker ?? new Invoker();
    }

    /**
     * Invoke code generation.
     *
     * @param string $name    Function name
     * @param Routes $routes
     * @return string
     */
    public function __invoke(string $name, Routes $routes): string
    {
        $structure = $routes->structure();

        $default = $structure["\e"] ?? null;
        unset($structure["\e"]);

        $switchCode = self::indent($this->generateSwitch($structure));
        $defaultCode = self::indent($this->generateDefault($default));

        [$namespace, $function] = $this->generateNs($name);

        return <<<CODE
<?php

declare(strict_types=1);
{$namespace}
/**
 * This function is generated by SwitchRoute.
 * Do not modify it manually. Any changes will be overwritten.
 */
function {$function}(string \$method, string \$path, ?callable \$instantiate = null)
{
    \$segments = \$path === "/" ? [] : explode("/", trim(\$path, "/"));
    \$allowedMethods = [];

$switchCode

$defaultCode
}
CODE;
    }

    /**
     * Generate code for an endpoint
     *
     * @param Endpoint $endpoint
     * @return string
     */
    protected function generateEndpoint(Endpoint $endpoint): string
    {
        $exportValue = function ($var): string {
            return var_export($var, true);
        };

        return join("\n", [
            "\$allowedMethods = [" . join(', ', array_map($exportValue, $endpoint->getAllowedMethods())) . "];",
            parent::generateEndpoint($endpoint)
        ]);
    }

    /**
     * Generate routing code for an endpoint.
     *
     * @param string        $key
     * @param array         $route
     * @param array         $vars
     * @param callable|null $genArg
     * @return string
     * @throws InvalidRoute
     */
    protected function generateRoute(string $key, array $route, array $vars, ?callable $genArg = null): string
    {
        if (!isset($route['include']) && !isset($route['controller']) && !isset($route['action'])) {
            throw new InvalidRoute("Route for '$key' should specify 'include', 'controller', " .
                "or 'action'");
        }

        if (isset($route['include'])) {
            return "return require '" . addslashes($route['include']) . "';";
        }

        try {
            $genArg = $genArg ?? function (?string $name, ?string $type = null, $default = null) use ($vars): string {
                return $this->genArg($vars, $name, $type, $default);
            };
            $new = '(isset($instantiate) ? ($instantiate)(\'%1$s\') : new \\%1$s)';

            $invocation = $this->invoker->generateInvocation($route, $genArg, $new);
        } catch (ReflectionException $exception) {
            throw new InvalidRoute("Invalid route for '$key'. ". $exception->getMessage(), 0, $exception);
        }

        return "return $invocation;";
    }

    /**
     * Generate code for when no route matches.
     *
     * @param Endpoint|null $endpoint
     * @return string
     * @throws InvalidRoute
     */
    protected function generateDefault(?Endpoint $endpoint): string
    {
        if ($endpoint === null) {
            return $this->invoker->generateDefault();
        }

        $genArg = function ($name, $type = null, $default = null) {
            return "\${$name} ?? " . var_export($default, true);
        };

        return $this->generateRoute('default', $endpoint->getRoutes()[''], [], $genArg);
    }

    /**
     * Generate code for argument using path vars.
     *
     * @param array       $vars
     * @param string|null $name
     * @param string|null $type
     * @param mixed       $default
     * @return string
     */
    protected function genArg(array $vars, ?string $name, ?string $type = null, $default = null): string
    {
        if ($name === null) {
            $fnMap = function ($name, $pos) {
                return sprintf('"%s" => $segments[%d]', addslashes($name), $pos);
            };

            return '[' . join(', ', array_map($fnMap, array_keys($vars), $vars)) . ']';
        }

        return isset($vars[$name]) ? "\$segments[{$vars[$name]}]" : var_export($default, true);
    }
}
